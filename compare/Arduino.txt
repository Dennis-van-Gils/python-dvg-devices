def query(self, msg_str, timeout_warning_style=1):
    """Send a message to the serial device and subsequently read the reply.

    Args:
        msg_str (str):
            Message to be sent to the serial device.
        timeout_warning_style (int, optional):
            Work-around for the Serial library not throwing an exception
            when read has timed out.
            1 (default): Will print a traceback error message on screen and
            continue.
            2: Will raise the exception again.

    Returns:
        success (bool):
            True if successful, False otherwise.
        ans_str (str):
            Reply received from the device. [None] if unsuccessful.
    """
    success = False
    ans_str = None

    if self.write(msg_str, timeout_warning_style):
        try:
            ans_bytes = self.ser.read_until(self.read_term_char.encode())
        except (
            serial.SerialTimeoutException,
            serial.SerialException,
        ) as err:
            # Note: The Serial library does not throw an exception when it
            # times out in `read`, only when it times out in`write`! We
            # will check for zero received bytes as indication for a read
            # timeout, later.
            # See https://stackoverflow.com/questions/10978224/serialtimeoutexception-in-python-not-working-as-expected
            pft(err, 3)
        except Exception as err:
            pft(err, 3)
            sys.exit(0)
        else:
            if len(ans_bytes) == 0:
                # Received 0 bytes, probably due to a timeout.
                if timeout_warning_style == 1:
                    pft("Received 0 bytes. Read probably timed out.", 3)
                elif timeout_warning_style == 2:
                    raise serial.SerialTimeoutException
            else:
                try:
                    ans_str = ans_bytes.decode("utf8").strip()
                except UnicodeDecodeError as err:
                    # Print error and struggle on
                    pft(err, 3)
                except Exception as err:
                    pft(err, 3)
                    sys.exit(0)
                else:
                    success = True

    return [success, ans_str]
    
def write(self, msg_str, timeout_warning_style=1):
    """Send a message to the serial device.

    Args:
        msg_str (str):
            String to be sent to the serial device.
        timeout_warning_style (int, optional):
            1 (default): Will print a traceback error message on screen and
            continue.
            2: Will raise the exception again.

    Returns: True if successful, False otherwise.
    """
    success = False

    if not self.is_alive:
        pft("Device is not connected yet or already closed.", 3)
    else:
        try:
            self.ser.write((msg_str + self.write_term_char).encode())
        except (
            serial.SerialTimeoutException,
            serial.SerialException,
        ) as err:
            if timeout_warning_style == 1:
                pft(err, 3)
            elif timeout_warning_style == 2:
                raise (err)
        except Exception as err:
            pft(err, 3)
            sys.exit(0)
        else:
            success = True

    return success